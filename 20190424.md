## golang

- gin.Contextのgodoc読んだ
	- gin.Context.Status(code int)
	- gin.Context.String(code int, format string, values ...interface{})
	- gin.Context.JSON(code int, obj interface{})
- anonymous api実装(/)

**golangのconst識別子iota**  


## code rule

全部覚えるのとか無理なので、  
レビュイーが迷ったときに参照する程度の指針としていく  

**基本**  

- あらゆる場所から依存できるパッケージの生成
	- constant.goとかそんな感じのもの
	- 必要なところに必要なだけ用意する

**goimports/gofmtは必須**  

- importブロック内のソートもgoimportsに任せる
- 基本的な自動整形もすべてgofmtに任せる

**基本的な命名規則**  

- 頭文字語はすべて大文字か小文字に統一する(HtmlやXml、Id、Dbのようにしない)
- バージョンぽい命名禁止(GetMerchant2, MerchantHogeHogeV1)
- スネークケースではなくキャメルケース(constでもNG)

**変数の命名規則**  

- ローカル変数については、対象の命名をキャメルケース化した時の頭文字同士を繋げた短いものにする
	- MerchantInformation => mi
	- UserAuthApplication => uaa
- 参照スコープがパッケージ外になっている変数は命名で意味がわかるようにする

**interface型の扱い**  

- interfaceを取得する関数はNewXXXX() interface{}とする
- interfaceを満たす為の構造体は外部から参照できてはいけない
	- interfaceを定義する構造体は小文字で始めて、パッケージ内に隠蔽する

**repository層の命名規則**  

- 1件だけ取得する為の命名
	- FindBy{引数に指定する条件} => 返り値は単数であってスライスではない
- 複数件を取得する為の命名
	- FindAllBy{引数に指定する条件} => 返り値はスライスであって単数ではない

**スライス型の扱い**  

- スライスのポインタ禁止、構造体自体のポインタを使う
	- []*Merchantとすること
	- *[]MerchantはNG
	- スライスを扱う際にnilと空かどうかのチェックが必要になってしまう
	- スライスは常にnilを許可せず、空かどうかわかればいい

**ポインタ型の扱い**  

- 基本型でポインタは使わない
- omitemptyなどでゼロ値とnilを分けたい場合はとりあえず設計を見直してください
	- どうしても、必要な場合はtypeでの別名定義を検討する
	- 例えば、true|false|nilの3パターンを扱いたい場合は、type Boolean boolとして、*Boolean型として使うようにする
- 構造体は大小問わずポインタ型で扱う
	- 公式では小さい構造体はオーバーヘッドがないので値でもポインタでもいいとあるが、記述上ややこしくなるので

**error型について**  

- 関数の戻り値がerrorインターフェース型の値1つの場合、省略記法を使う
```go
if err := HelloWorld(); err != nil {
    return nil
}

v, err := HelloWorld()
if err != nil {
    return nil
}
```
- mainパッケージのmain関数以外でのpanic禁止(必ずreturn errorすること)
- error値生成時はfmt.Errorfに統一(errors.New禁止)
	- formatを使いたい場合、errors.New(fmt.Sprintf("%s", "hoge"))のように冗長になるので
- errorを生成する必要がないときにreturn v, nilしない(errorが不要なら返り値から消す)
- error返り値をブランク識別子に代入しない(v, _ := FuncHogeHoge())

**変数の初期化について**  

- ゼロ値での初期化不要(var str string = "") => (var str string)
